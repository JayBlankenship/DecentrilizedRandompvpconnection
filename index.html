<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Decentralized Chain Chat</title>
  <style>
    body {
      background: #000;
      color: #00ff00;
      font-family: 'Consolas', 'Courier New', monospace;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      box-sizing: border-box;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
      padding: 24px 0 0 0;
      display: flex;
      flex-direction: row;
      gap: 24px;
    }
    .main-panel {
      flex: 2;
      display: flex;
      flex-direction: column;
    }
    .side-panel {
      flex: 1;
      background: #001a00;
      border-left: 2px solid #00ff00;
      padding: 16px;
      min-width: 260px;
      max-width: 340px;
      border-radius: 0 8px 8px 0;
      box-shadow: 0 0 12px #003300 inset;
    }
    h1 {
      font-size: 2em;
      margin: 0 0 16px 0;
      color: #00ff00;
      letter-spacing: 2px;
      text-shadow: 0 0 8px #00ff00;
    }
    .status-bar {
      margin-bottom: 12px;
      font-size: 1.1em;
      background: #001a00;
      border: 1px solid #00ff00;
      border-radius: 6px;
      padding: 8px 12px;
      box-shadow: 0 0 8px #003300 inset;
    }
    #peerListDisplay {
      margin-bottom: 8px;
      font-size: 1em;
    }
    #chatMessages {
      background: #000;
      border: 1px solid #00ff00;
      height: 40vh;
      overflow-y: auto;
      padding: 10px;
      margin: 10px 0 0 0;
      font-size: 1em;
      white-space: pre-wrap;
      color: #00ff00;
      border-radius: 6px;
      box-shadow: 0 0 8px #003300 inset;
    }
    #chatMessages .my-message {
      color: #00cc00;
      font-weight: bold;
    }
    .input-row {
      display: flex;
      gap: 8px;
      margin: 10px 0 0 0;
    }
    input, button {
      background: #000;
      color: #00ff00;
      border: 1px solid #00ff00;
      font-family: 'Consolas', 'Courier New', monospace;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 1em;
      box-shadow: none;
      transition: background 0.2s, color 0.2s;
    }
    input:focus, button:focus {
      outline: 1px solid #00cc00;
    }
    button:hover {
      background: #00ff00;
      color: #000;
      cursor: pointer;
    }
    #messageInput, #targetPeerId {
      width: 220px;
    }
    .output-panel {
      background: #000;
      border: 1px solid #00ff00;
      color: #00ff00;
      font-size: 0.95em;
      padding: 10px;
      margin-top: 12px;
      border-radius: 6px;
      height: 22vh;
      overflow-y: auto;
      box-shadow: 0 0 8px #003300 inset;
    }
    .output-panel strong {
      color: #00ff99;
    }
    .side-panel h3 {
      margin-top: 0;
      color: #00ff99;
      font-size: 1.1em;
      letter-spacing: 1px;
    }
    .side-panel ul {
      padding-left: 18px;
      margin: 0 0 10px 0;
    }
    .side-panel li {
      color: #00ff99;
      margin-bottom: 2px;
      font-size: 0.98em;
    }
    .side-panel .info-label {
      color: #00ff99;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="main-panel">
      <h1>Decentralized Chain Chat</h1>
      <div class="status-bar">
        Chain Status: <span id="chainStatus">Initializing</span>
        <span id="basePeerIndicator" style="margin-left:16px;font-weight:bold;"></span>
        <button onclick="joinChain()">Join/Rejoin Chain</button>
      </div>
      <div id="peerListDisplay">
        <strong>Chain Position:</strong> <span id="chainPosition">Unknown</span> |
        <strong>Total Peers in Chain:</strong> <span id="peerCount">0</span> |
        <strong>Next Peer:</strong> <span id="nextPeer">None</span> |
        <strong>Previous Peer:</strong> <span id="prevPeer">None</span>
      </div>
      <div id="peerInfo">My peer ID: <span id="myPeerId">Initializing...</span></div>
      <div id="connectionStatus"></div>
      <h3>Chat</h3>
      <div id="chatMessages"></div>
      <div class="input-row">
        <input id="messageInput" placeholder="Type a message" type="text">
        <input id="targetPeerId" placeholder="Recipient Peer ID (leave blank for broadcast)" type="text">
        <button onclick="sendMessage()">Send</button>
      </div>
    <div class="output-panel" id="outputPanel">
      <strong>Diagnostics & State:</strong>
      <div id="diagnosticsStatic"></div>
      <div id="diagnostics"></div>
    </div>
    <div class="output-panel" id="chainLogPanel">
      <strong>Chain Propagation Log:</strong>
      <div id="chainLog"></div>
    </div>
    </div>
    <div class="side-panel">
      <h3>Peer Chain</h3>
      <ul id="peerChainList"></ul>
      <h3>Connections</h3>
      <ul>
        <li><span class="info-label">Front Peer:</span> <span id="frontPeerId">-</span></li>
        <li><span class="info-label">Back Peer:</span> <span id="backPeerId">-</span></li>
        <li><span class="info-label">Front Conn:</span> <span id="frontConnStatus">-</span></li>
        <li><span class="info-label">Back Conn:</span> <span id="backConnStatus">-</span></li>
      </ul>
    </div>
  </div>

  <!-- PeerJS -->
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script>
    // --- CONFIG ---
    const BASE_PEER_ID = 'ChainBootstrap-2025-001';
    let myPeerId = null;
    let peer = null;
    let isBase = false;
    let paired = false;
    let partnerPeerId = null;
    let partnerConn = null;
    let messagesArray = [];
    let isInitialized = false;

    // UI Elements
    const chainStatus = document.getElementById('chainStatus');
    const chainPositionSpan = document.getElementById('chainPosition');
    const peerCount = document.getElementById('peerCount');
    const nextPeerSpan = document.getElementById('nextPeer');
    const prevPeerSpan = document.getElementById('prevPeer');
    const chatMessages = document.getElementById('chatMessages');
    const messageInput = document.getElementById('messageInput');
    const targetPeerId = document.getElementById('targetPeerId');
    const peerInfoDiv = document.getElementById('peerInfo');
    const connectionStatusDiv = document.getElementById('connectionStatus');
    const outputPanel = document.getElementById('outputPanel');
    const diagnosticsDiv = document.getElementById('diagnostics');
    const diagnosticsStaticDiv = document.getElementById('diagnosticsStatic');
    const peerChainList = document.getElementById('peerChainList');
    const frontPeerIdSpan = document.getElementById('frontPeerId');
    const backPeerIdSpan = document.getElementById('backPeerId');
    const frontConnStatusSpan = document.getElementById('frontConnStatus');
    const backConnStatusSpan = document.getElementById('backConnStatus');
    const chainLogDiv = document.getElementById('chainLog');

    function logChainEvent(msg, color='#ffaa00') {
      // Append log message, never clear or truncate
      chainLogDiv.insertAdjacentHTML('beforeend', `<div style='color:${color}'>${msg}</div>`);
      chainLogDiv.scrollTop = chainLogDiv.scrollHeight;
    }

    function logDiag(msg, color='#44ff44') {
      diagnosticsDiv.insertAdjacentHTML('beforeend', `<div style='color:${color}'>${msg}</div>`);
      diagnosticsDiv.scrollTop = diagnosticsDiv.scrollHeight;
    }

    function startPeer() {
      myPeerId = `ChainNode-${Math.random().toString(36).substr(2, 8)}`;
      peer = new Peer(myPeerId, {
        host: '0.peerjs.com', port: 443, path: '/', secure: true,
        config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }
      });
      peer.on('open', (id) => {
        isInitialized = true;
        peerInfoDiv.querySelector('#myPeerId').textContent = myPeerId;
        tryBecomeBase();
      });
      peer.on('connection', (conn) => {
        conn.on('data', (data) => handleData(conn, data));
        conn.on('open', () => {
          logDiag(`[Conn] Incoming connection from ${conn.peer}`);
        });
        conn.on('close', () => logDiag(`[Conn] Connection closed: ${conn.peer}`, '#ff4444'));
        conn.on('error', (err) => logDiag(`[Conn] Error: ${err.message}`, '#ff4444'));
      });
      peer.on('error', (err) => {
        connectionStatusDiv.textContent = `Peer error: ${err.message}`;
        logDiag(`[Peer] Error: ${err.message}`, '#ff4444');
      });
    }

    // --- Peer connection registry for base peer ---
    let basePeerConnections = {};

    function tryBecomeBase() {
      // Try to become the base peer
      const basePeer = new Peer(BASE_PEER_ID, {
        host: '0.peerjs.com', port: 443, path: '/', secure: true,
        config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }
      });
      basePeer.on('open', (id) => {
        isBase = true;
        chainStatus.textContent = 'Waiting for a partner...';
        logDiag('[Base] Became base peer!');
        updateUI();
        let firstPeer = myPeerId;
        let secondPeer = null;
        basePeer.on('connection', (conn) => {
          conn.on('data', (data) => {
            if (data.type === 'join') {
              if (!secondPeer) {
                secondPeer = data.peerId;
                // Pair both peers
                basePeerConnections[firstPeer] = null; // base itself
                basePeerConnections[secondPeer] = conn;
                // Notify both peers
                conn.send({ type: 'pair', partnerPeerId: firstPeer });
                // Notify base peer itself
                setTimeout(() => {
                  handleData(null, { type: 'pair', partnerPeerId: secondPeer });
                  // Remove base status
                  isBase = false;
                  logDiag('[Base] Pair formed, base status removed.');
                  basePeer.destroy();
                  updateUI();
                }, 500);
              }
            }
          });
          conn.on('close', () => {
            for (const pid in basePeerConnections) {
              if (basePeerConnections[pid] === conn) {
                delete basePeerConnections[pid];
                break;
              }
            }
          });
        });
      });
      basePeer.on('error', (err) => {
        isBase = false;
        joinChain();
      });
    }


    // Propagate new peer join from the front of the chain, hop-by-hop
    function propagateNewPeerFromFront(newPeerId) {
      if (chain.length < 2) return; // No one to propagate to
      const firstPeer = chain[1];
      if (basePeerConnections[firstPeer]) {
        logDiag(`[Propagate] Starting propagation of new peer (${newPeerId}) at front: ${firstPeer}`);
        basePeerConnections[firstPeer].send({ type: 'new-peer', newPeerId });
      }
    }

    // Track base connection for later disconnect
    let baseConn = null;
    function joinChain() {
      chainStatus.textContent = 'Joining pair...';
      baseConn = peer.connect(BASE_PEER_ID);
      baseConn.on('open', () => {
        baseConn.send({ type: 'join', peerId: myPeerId });
        logDiag(`[Join] Sent join request to base`);
      });
      baseConn.on('data', (data) => {
        if (data.type === 'pair') {
          partnerPeerId = data.partnerPeerId;
          paired = true;
          logDiag(`[Join] Paired with: ${partnerPeerId}`);
          connectToPartner();
          chainStatus.textContent = 'Paired!';
          updateUI();
        }
      });
      baseConn.on('error', (err) => {
        chainStatus.textContent = 'Failed to join pair';
        logDiag(`[Join] Error: ${err.message}`, '#ff4444');
      });
    }

    function broadcastChain() {
      // Only base peer does this
      if (!isBase) return;
      // Send updated chain to all peers (including self)
      for (let i = 0; i < chain.length; ++i) {
        if (chain[i] === myPeerId) {
          // Update self directly
          handleData(null, { type: 'chain', chain: [...chain] });
        } else if (basePeerConnections[chain[i]]) {
          // Use open connection if available
          basePeerConnections[chain[i]].send({ type: 'chain', chain: [...chain] });
        } else {
          // Fallback: try to connect and send (for legacy peers)
          const conn = peer.connect(chain[i]);
          conn.on('open', () => {
            conn.send({ type: 'chain', chain: [...chain] });
            conn.close();
          });
        }
      }
    }

    function updateChainLinks() {
      const idx = chain.indexOf(myPeerId);
      prevPeerId = idx > 0 ? chain[idx - 1] : null;
      nextPeerId = idx < chain.length - 1 ? chain[idx + 1] : null;
    }

    function connectToPartner() {
      if (partnerConn) { partnerConn.close(); partnerConn = null; }
      if (partnerPeerId) {
        partnerConn = peer.connect(partnerPeerId);
        partnerConn.on('open', () => {
          logDiag(`[Conn] Connected to partner: ${partnerPeerId}`);
          if (baseConn) {
            logDiag('[Pair] Disconnecting from base peer (island formed)');
            baseConn.close();
            baseConn = null;
          }
        });
        partnerConn.on('data', (data) => handleData(partnerConn, data));
        partnerConn.on('close', () => {
          logDiag(`[Conn] Partner connection closed, will attempt reconnect`, '#ff4444');
        });
      }
      updateUI();
    }

    // Periodically check and reconnect to neighbors if needed
    setInterval(() => {
      if (!isInitialized) return;
      if (partnerPeerId && (!partnerConn || partnerConn.open === false)) {
        logDiag(`[Auto] Reconnecting to partner: ${partnerPeerId}`, '#00ccff');
        partnerConn = peer.connect(partnerPeerId);
        partnerConn.on('open', () => logDiag(`[Auto] Reconnected to partner: ${partnerPeerId}`));
        partnerConn.on('data', (data) => handleData(partnerConn, data));
      }
    }, 5000);

    function handleData(conn, data) {
      if (data.type === 'pair') {
        partnerPeerId = data.partnerPeerId;
        paired = true;
        connectToPartner();
        updateUI();
      } else if (data.type === 'message') {
        handleMessage(data);
        if (data.from !== myPeerId) {
          relayMessage(data, conn ? conn.peer : null);
        }
      }
    }

    function relayMessage(data, fromPeer) {
      // Relay only to partner, except the one we got it from
      if (partnerPeerId && partnerPeerId !== fromPeer && partnerConn && partnerConn.open) {
        partnerConn.send(data);
      }
    }

    function handleMessage(data) {
      if (data.messages) {
        data.messages.forEach((m) => {
          if (!messagesArray.some((existing) => existing.id === m.id)) {
            messagesArray.push(m);
          }
        });
        messagesArray.sort((a, b) => a.timestamp - b.timestamp);
        updateUI();
      }
    }

    function sendMessage() {
      if (!isInitialized) {
        connectionStatusDiv.textContent = 'Error: Peer not initialized.';
        return;
      }
      const text = messageInput.value.trim();
      if (!text) {
        connectionStatusDiv.textContent = 'Error: Message cannot be empty.';
        return;
      }
      const message = {
        id: `${myPeerId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        peerId: myPeerId,
        text: text,
        timestamp: Date.now(),
      };
      messagesArray.push(message);
      messagesArray.sort((a, b) => a.timestamp - b.timestamp);
      const payload = {
        type: 'message',
        messages: [message],
        from: myPeerId
      };
      // Send only to partner
      if (partnerConn && partnerConn.open) partnerConn.send(payload);
      connectionStatusDiv.textContent = 'Message sent to partner.';
      messageInput.value = '';
      targetPeerId.value = '';
      updateUI();
    }

    function updateUI() {
      chainPositionSpan.textContent = paired ? 'Paired' : (isBase ? 'Base' : 'Waiting');
      peerCount.textContent = paired ? '2' : (isBase ? '1 or waiting' : '1');
      nextPeerSpan.textContent = partnerPeerId || 'None';
      prevPeerSpan.textContent = '-';
      frontPeerIdSpan.textContent = partnerPeerId || '-';
      backPeerIdSpan.textContent = '-';
      frontConnStatusSpan.textContent = (partnerConn && partnerConn.open) ? 'Connected' : 'Disconnected';
      backConnStatusSpan.textContent = '-';
      // Peer chain list
      peerChainList.innerHTML = '';
      if (paired) {
        [myPeerId, partnerPeerId].forEach((pid, idx2) => {
          const li = document.createElement('li');
          li.textContent = `#${idx2}: ${pid}`;
          if (pid === myPeerId) li.style.color = '#00ffcc';
          peerChainList.appendChild(li);
        });
      } else {
        const li = document.createElement('li');
        li.textContent = `#0: ${myPeerId}`;
        li.style.color = '#00ffcc';
        peerChainList.appendChild(li);
      }
      // Never clear the chainLogDiv here or anywhere else
      // Base peer indicator
      const basePeerIndicator = document.getElementById('basePeerIndicator');
      if (isBase) {
        basePeerIndicator.textContent = 'You are the BASE peer (waiting for partner)';
        basePeerIndicator.style.color = '#00ff99';
      } else if (paired) {
        basePeerIndicator.textContent = 'You are paired with another peer';
        basePeerIndicator.style.color = '#00ccff';
      } else {
        basePeerIndicator.textContent = 'Waiting for a partner...';
        basePeerIndicator.style.color = '#ffaa00';
      }
      // Diagnostics (static info only, never clear logs)
      diagnosticsStaticDiv.innerHTML = `
        <div><strong>My Peer ID:</strong> ${myPeerId}</div>
        <div><strong>Partner Peer ID:</strong> ${partnerPeerId || '-'}</div>
        <div><strong>Pair Status:</strong> ${paired ? 'Paired' : (isBase ? 'Base' : 'Waiting')}</div>
        <div><strong>Total Peers in Pair:</strong> ${paired ? '2' : (isBase ? '1 or waiting' : '1')}</div>
        <div><strong>Partner Conn Status:</strong> ${(partnerConn && partnerConn.open) ? 'Connected' : 'Disconnected'}</div>
        <div><strong>Peer Role:</strong> ${isBase ? 'BASE (waiting)' : (paired ? 'PAIRED' : 'WAITING')}</div>
      `;
      // Chat
      chatMessages.innerHTML = messagesArray
        .map((m) => {
          const isMyMessage = m.peerId === myPeerId;
          return `<div${isMyMessage ? ' class="my-message"' : ''}>${m.peerId}: ${m.text}</div>`;
        })
        .join('');
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    window.sendMessage = sendMessage;
    window.joinChain = joinChain;

    // Start everything
    startPeer();
  </script>
</body>
</html>